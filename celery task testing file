from celery import shared_task, group
from django.utils.timezone import now
from django.db.models import Q, Count
from django.template.loader import render_to_string
from django.core.mail import send_mail
from django.conf import settings
import logging
from click_for_marry.constants import NOTIFICATION_TYPE_DELIVERY_CONSTANTS


from .models import UserPlan, PlanStatus
from common.models import NotificationSettings, NotificationType
from django.contrib.auth import get_user_model

logger = logging.getLogger(__name__)
User = get_user_model()



def expire_user_plans_task():
    """
    Main task:
    - Expire plans in bulk (to-the-second accuracy)
    - Find users who ONLY have expired plans
    - Dispatch subtasks to notify them
    """
    now_ts = now()   

    # Expire all plans that ended before current timestamp
    newly_expired_count = (
        UserPlan.objects.filter(end_date__lt=now_ts)
        .exclude(status=PlanStatus.EXPIRED)
        .update(status=PlanStatus.EXPIRED, days_remaining=0)
    )

    # Get users who ONLY have expired plans (no active)
    users_with_expired_only = (
        User.objects.annotate(
            active_plan_count=Count("user_plans", filter=Q(user_plans__status=PlanStatus.ACTIVE))# user_plans - related name
        )
        .filter(user_plans__status=PlanStatus.EXPIRED, active_plan_count=0)
        .distinct()
    )

    if not users_with_expired_only.exists():
        return f"Processed {newly_expired_count} new expirations. No users to notify."

    tasks = [send_plan_expired_notification(user.id) for user in users_with_expired_only]
    group(tasks).apply_async()

    return f"Processed {newly_expired_count} new expirations. Dispatched {len(tasks)} notification tasks."



def send_plan_expired_notification(user_id):
    """
    Subtask: Send push/SMS/email notifications for one user
    """
    try:
        user = User.objects.get(id=user_id)

        # Get user notification setting for PLAN_EXPIRED
        try:
            user_setting = NotificationSettings.objects.get(
                user=user, notification_type=NotificationType.PLAN_EXPIRED
            )
        except NotificationSettings.DoesNotExist:
            logger.warning(f"No PLAN_EXPIRED notification setting for user {user.id}")
            return f"Skipped user {user.id} (no settings)"

        # Get expired plans
        expired_plans = UserPlan.objects.filter(
            user=user, status=PlanStatus.EXPIRED
        ).order_by("-end_date")

        if not expired_plans.exists():
            return f"Skipped user {user.id} (no expired plans)"

        latest_expiration = expired_plans.first().end_date
        data = NOTIFICATION_TYPE_DELIVERY_CONSTANTS.get("PLAN_EXPIRED", {})

        # Push notification
        if user_setting.push == NotificationSettings.SmsEmailPushTypes.ON:
            push_data = data.get("push", {})
            logger.info(f"[PUSH] To {user.username}: {push_data.get('title')}")

        # SMS notification
        if user_setting.sms == NotificationSettings.SmsEmailPushTypes.ON:
            sms_data = data.get("sms", {})
            logger.info(f"[SMS] To {user.username}: {sms_data.get('title')}")

        # Email notification
        if user_setting.email == NotificationSettings.SmsEmailPushTypes.ON and user.email:
            email_data = data.get("email", {})
            subject = email_data.get("title", "Plan Expired")
            template = email_data.get("template")

            if template:
                email_body = render_to_string(
                    template,
                    {
                        "user": user,
                        "user_plans": expired_plans,
                        "latest_expiration": latest_expiration,
                    },
                )

                send_mail(
                    subject,
                    "",
                    settings.DEFAULT_FROM_EMAIL,
                    [user.email],
                    html_message=email_body,
                    fail_silently=False,
                )
                logger.info(f"Expiration email sent to {user.email}")

        return f"Notified user {user.id}"

    except Exception as e:
        logger.error(f"Error sending notification for user {user_id}: {e}")
        return f"Error for user {user_id}"


if __name__ == "__main__":
    print(expire_user_plans_task())
