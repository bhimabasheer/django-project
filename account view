from rest_framework import status
from rest_framework.views import APIView
from datetime import datetime, timezone as dt_timezone
from rest_framework.response import Response
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework_simplejwt.views import TokenObtainPairView
from rest_framework_simplejwt.tokens import RefreshToken,TokenError
import jwt
from django.utils import timezone
from rest_framework import status
from users.models import Users, Session, AccountDeletionReason
from common.models import Activity
from .serializers import (PreRegisterSerializer, CreateAccountWithOTPSerializer,
ProfileCreatedForSerializer, CustomTokenObtainPairSerializer, CustomTokenObtainSerializer,
OTPForLoginSerializer, VerifyLoginOTPSerializer,WebPreRegisterSerializer,WebVerifyOTPSerializer,
WebCreateAccountSerializer,ChangePasswordSerializer,AccountDeletionReasonSerializer)
import uuid
from django.conf import settings
from utils.api_response import success_,error_
from click_for_marry import constants as const
from utils.helpers import Utils
from .utils import Utils as AccountUtils
import json

class CreateAccountAPIView(APIView):
    permission_classes = [AllowAny]
    
    def post(self, request):
        try:
            request_data = request.data
            serializer = PreRegisterSerializer(data=request_data)
            serializer.is_valid()
            if not serializer.is_valid():
                error = serializer.errors
                errors = json.loads(json.dumps(error))

                    # combine errors to form a single word
                errors_data = Utils.extract_validation_error(errors)
                return Response(error_(message=errors_data),status=status.HTTP_200_OK)
            
            data = serializer.validated_data
            
            code = serializer.create_otp(data)
            response = {"otp": code}
            message = f"OTP sent to {data.get('identifier')}"
            return Response(success_(message=message, response=response),status=status.HTTP_200_OK)
        except Exception as e:
            import traceback
            print(traceback.format_exc())
            return Response(error_(message=str(e)),status=status.HTTP_400_BAD_REQUEST)

class CreateAccountWithOTPAPIView(APIView):
    permission_classes = [AllowAny]
    
    def get_expiry_seconds(self, token_payload):
        now = datetime.now(dt_timezone.utc)
        exp_dt = datetime.fromtimestamp(token_payload['exp'], tz=dt_timezone.utc)
        return max(0, int((exp_dt - now).total_seconds()))
    
    def post(self, request):
        try:
            serializer = CreateAccountWithOTPSerializer(data=request.data)
            if not serializer.is_valid():
                error = serializer.errors
                errors = json.loads(json.dumps(error))

                    # combine errors to form a single word
                errors_data = Utils.extract_validation_error(errors)
                return Response(error_(message=errors_data),status=status.HTTP_200_OK)

            # Create user and generate tokens
            data = serializer.validated_data
            user = serializer.create(data)
            refresh = RefreshToken.for_user(user)
            access_payload = jwt.decode(str(refresh.access_token), options={"verify_signature": False})
            refresh_payload = jwt.decode(str(refresh), options={"verify_signature": False})
            response_data= {
                "access": str(refresh.access_token),
                "refresh": str(refresh),
                "user": Utils.get_user_data(user),
                "device_id": Utils.get_device_id(request),
                "access_expires": access_payload['exp'],
                "refresh_expires": refresh_payload['exp'],
                "expires_in": {
                    "access": self.get_expiry_seconds(access_payload),
                    "refresh": self.get_expiry_seconds(refresh_payload)
                },
                **AccountUtils.get_common_login_response(user=user)
            }
            return Response(success_(response=response_data, message="Account created successfully"),
                            status=status.HTTP_200_OK)
        except Exception as e:
            return Response(error_(message=str(e), response={}),
                        status=status.HTTP_400_BAD_REQUEST)
          
class CustomTokenObtainPairView(TokenObtainPairView):
    serializer_class = CustomTokenObtainPairSerializer
    
class CustomLoginView(APIView):
    permission_classes = [AllowAny]

    def get_expiry_seconds(self, token_payload):
        now = datetime.now(dt_timezone.utc)
        exp_dt = datetime.fromtimestamp(token_payload['exp'], tz=dt_timezone.utc)
        return max(0, int((exp_dt - now).total_seconds()))

    def post(self, request):
        device_id = Utils.get_device_id(request)
        serializer = CustomTokenObtainSerializer(data=request.data)
        if not serializer.is_valid():
            error = serializer.errors
            errors = json.loads(json.dumps(error))

                # combine errors to form a single word
            errors_data = Utils.extract_validation_error(errors)
            return Response(error_(message=errors_data),status=status.HTTP_200_OK)
        
        data = serializer.validated_data
        user = data['user']
        Session.objects.update_or_create(
                user=user,
                session_id=str(uuid.uuid4()),
                device_type=request.data.get('device_type', 1),
                device_id=device_id,
                last_login=timezone.now()
            )

        Activity.objects.create(
            user=user,
            op="User logged in",
            ip_address=Utils.get_client_ip(request),
            device_id=device_id
        )

        access_payload = jwt.decode(data['access'], options={"verify_signature": False})
        refresh_payload = jwt.decode(data['refresh'], options={"verify_signature": False})

        response_data= {
            "access": data["access"],
            "refresh": data["refresh"],
            "user": Utils.get_user_data(user),
            "device_id": device_id,
            "access_expires": access_payload['exp'],
            "refresh_expires": refresh_payload['exp'],
            "expires_in": {
                "access": self.get_expiry_seconds(access_payload),
                "refresh": self.get_expiry_seconds(refresh_payload)
            },
            **AccountUtils.get_common_login_response(user=user)
        }

        return Response(success_(message=const.LOGIN_SUCCESS,response=response_data,),
                        status=status.HTTP_200_OK)

class LogoutAPIView(APIView):
    def post(self, request):
        try:
            refresh_token = request.data.get("refresh")
            if not refresh_token:
                return Response(error_(message="Refresh token is required"),
                            status=status.HTTP_400_BAD_REQUEST)

            try:
                token = RefreshToken(refresh_token)
                if token.payload.get('user_id') != request.user.id:
                    raise ValueError("Token doesn't belong to user")
                token.blacklist()
            except Exception as token_error:
                return Response(error_(message="Invalid token", response=str(token_error)),
                            status=status.HTTP_401_UNAUTHORIZED)

            # Device-specific logout
            device_id = request.data.get("device_id") or Utils.get_device_id(request)
            sessions_terminated = Session.objects.filter(
                user=request.user, 
                device_id=device_id
            ).delete()[0]

            Activity.objects.create(
                user=request.user,
                op="User logged out",
                ip_address=Utils.get_client_ip(request),
                device_id=device_id
            )
           
            response_data = {
                "sessions_terminated": sessions_terminated,
                "device_id": device_id,
                "logout_time": timezone.now()
            }
            return Response(success_(response=response_data, message="Logout successful."),
                        status=status.HTTP_200_OK)
            
        except Exception as e:
            return Response(error_(message="Logout failed", response=str(e)),
                            status=status.HTTP_400_BAD_REQUEST)
        
class TokenRefreshView(APIView):
    permission_classes = [AllowAny]  

    def get_expiry_seconds(self, exp_timestamp):
        
        now = datetime.now(dt_timezone.utc)
        exp_dt = datetime.fromtimestamp(exp_timestamp, tz=dt_timezone.utc)
        return max(0, int((exp_dt - now).total_seconds()))

    def post(self, request):
        refresh_token = request.data.get("refresh")
        device_id = Utils.get_device_id(request)
        
        if not refresh_token:
            return Response(error_(message="Refresh token is required"),
                          status=status.HTTP_400_BAD_REQUEST)

        try:
            refresh = RefreshToken(refresh_token)
            user_id = refresh.payload.get('user_id')
            
            try:
                user = Users.objects.get(id=user_id)
            except Users.DoesNotExist:
                return Response(error_(message="User not found"),
                            status=status.HTTP_401_UNAUTHORIZED)

            # Implement token rotation
            refresh.blacklist()
            
            # Create new tokens
            new_refresh = RefreshToken.for_user(user)
            new_access = str(new_refresh.access_token)

            # Prepare response data
            response_data = {
                "access": new_access,
                "refresh": str(new_refresh),
                "user": Utils.get_user_data(user),
                "device_id": device_id,
                "access_expires": new_refresh.access_token.payload['exp'],
                "refresh_expires": new_refresh.payload['exp'],
                "expires_in": {
                    "access": self.get_expiry_seconds(new_refresh.access_token.payload['exp']),
                    "refresh": self.get_expiry_seconds(new_refresh.payload['exp'])
                }
            }
            
            return Response(success_(response=response_data, message="Token refreshed successfully"),
                          status=status.HTTP_200_OK)

        except Exception as e:
            error_msg = "Invalid token"
            if isinstance(e, TokenError):
                error_msg = str(e)
            
            return Response(error_(message=error_msg, response={"error": str(e)}),
                          status=status.HTTP_401_UNAUTHORIZED)


class ProtectedView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        
        response_data = {
                    "username": request.user.username,
                    "email": request.user.email,
                    "id": request.user.id,
                    "aec_id": request.user.aec_id
                }
        
        return Response(success_(response=response_data, message="Authenticated successfully"),
                          status=status.HTTP_200_OK)
    
class OTPForLoginView(APIView):
    permission_classes = [AllowAny]

    def post(self, request):
        try:
            serializer = OTPForLoginSerializer(data=request.data)
            platform = int(request.headers.get('X-Platform', const.PLATFORM_WEB))
            if serializer.is_valid():
                data = serializer.validated_data
                token = serializer.create_otp(data,platform)  
                return Response(success_(response=token, message="OTP sent successfully"),
                            status=status.HTTP_200_OK)
            else:
                error = serializer.errors
                errors = json.loads(json.dumps(error))

                    # combine errors to form a single word
                errors_data = Utils.extract_validation_error(errors)
                return Response(error_(message=errors_data),status=status.HTTP_200_OK)
        except Exception as e:
            import traceback
            print(traceback.format_exc())
            return Response(error_(message=str(e)),status=status.HTTP_400_BAD_REQUEST)
                          
class VerifyLoginOTPView(APIView):
    permission_classes = [AllowAny]

    def get_expiry_seconds(self, token_payload):
        now = datetime.now(dt_timezone.utc)
        exp_dt = datetime.fromtimestamp(token_payload['exp'], tz=dt_timezone.utc)
        return max(0, int((exp_dt - now).total_seconds()))
    
    def post(self, request):
        try:
            device_id = Utils.get_device_id(request)    
            serializer = VerifyLoginOTPSerializer(data=request.data)
            if serializer.is_valid():
                data = serializer.validated_data
                user = data["user"]
                Activity.objects.create(
                    user=user,
                    op="User logged in",
                    ip_address=Utils.get_client_ip(request),
                    device_id=device_id
                )

                access_payload = jwt.decode(data['access'], options={"verify_signature": False})
                refresh_payload = jwt.decode(data['refresh'], options={"verify_signature": False})

                response_data= {
                    "access": data["access"],
                    "refresh": data["refresh"],
                    "user": Utils.get_user_data(user),
                    "device_id": device_id,
                    "access_expires": access_payload['exp'],
                    "refresh_expires": refresh_payload['exp'],
                    "expires_in": {
                        "access": self.get_expiry_seconds(access_payload),
                        "refresh": self.get_expiry_seconds(refresh_payload)
                    },
                    **AccountUtils.get_common_login_response(user=user)
                }
                return Response(success_(response=response_data, message="Login successful."),
                            status=status.HTTP_200_OK)
            else:
                error = serializer.errors
                errors = json.loads(json.dumps(error))

                    # combine errors to form a single word
                errors_data = Utils.extract_validation_error(errors)
                return Response(error_(message=errors_data),status=status.HTTP_200_OK)
        except Exception as e:
            return Response(error_(message=str(e)),status=status.HTTP_400_BAD_REQUEST)
class SaveProfileCreatedForView(APIView):
    permission_classes = [IsAuthenticated]

    def get_expiry_seconds(self, token_payload):
        now = datetime.now(dt_timezone.utc)
        exp_dt = datetime.fromtimestamp(token_payload['exp'], tz=dt_timezone.utc)
        return max(0, int((exp_dt - now).total_seconds()))
    
    def patch(self, request):
        try:
            serializer = ProfileCreatedForSerializer(
                request.user,data=AccountUtils.get_profile_created_for_payload(request=request)
            )
            
            if serializer.is_valid():
                serializer.save()
                user = Users.objects.filter(id=request.user.id).first()
                refresh = RefreshToken.for_user(user)

                access_payload = jwt.decode(str(refresh.access_token), options={"verify_signature": False})
                refresh_payload = jwt.decode(str(refresh), options={"verify_signature": False})
                response_data= {
                    "access": str(refresh.access_token),
                    "refresh": str(refresh),
                    "user": Utils.get_user_data(user),
                    "device_id": Utils.get_device_id(request),
                    "access_expires": access_payload['exp'],
                    "refresh_expires": refresh_payload['exp'],
                    "expires_in": {
                        "access": self.get_expiry_seconds(access_payload),
                        "refresh": self.get_expiry_seconds(refresh_payload)
                    },
                    **AccountUtils.get_common_login_response(user=user) 
                }
                return Response(success_(response=response_data, message="Profile details updated successfully"),
                            status=status.HTTP_200_OK)
            else:
                error = serializer.errors
                errors = json.loads(json.dumps(error))

                    # combine errors to form a single word
                errors_data = Utils.extract_validation_error(errors)
                return Response(error_(message=errors_data),status=status.HTTP_200_OK)
        except Exception as e:
            return Response(error_(message=str(e)),status=status.HTTP_400_BAD_REQUEST)
       
       
# web app 
#Submit Profile + Name + Identifier → Send OTP

class WebPreRegisterAPIView(APIView):
    permission_classes = [AllowAny]

    def post(self, request):
        try:
            serializer = WebPreRegisterSerializer(data=request.data)
            if not serializer.is_valid():
                error = serializer.errors
                errors = json.loads(json.dumps(error))

                    # combine errors to form a single word
                errors_data = Utils.extract_validation_error(errors)
                return Response(error_(message=errors_data),status=status.HTTP_200_OK)
            
            validate_data = serializer.validated_data
            
            # Create and send OTP
            otp = serializer.create_otp(validate_data)
            identifier = validate_data.get('email') if validate_data.get('email') else validate_data.get('phone')
            print(f"OTP for {validate_data.get('email'), validate_data.get('phone')}: {otp}")
            message=f"OTP sent to {identifier}"
            
            response_data = {"otp": otp}
            return Response(success_(message=message,response=response_data),
                status=status.HTTP_200_OK
            )
        except Exception as e:
            import traceback
            print(traceback.format_exc())
            return Response(error_(message=str(e)),
                    status=status.HTTP_400_BAD_REQUEST
                )
        
#Verify OTP → Return Success (No Account Yet)
class WebVerifyOTPAPIView(APIView):
    permission_classes = [AllowAny]

    def post(self, request):
        try:
            request_data = request.data
            identifier = request_data.get("identifier",None)
            otp = request_data.get("otp",None)
            if not identifier or not otp:
                return Response(error_(message="Please provide a valid payload"),status=status.HTTP_200_OK )
            serializer = WebVerifyOTPSerializer(data=request_data)

            if not serializer.is_valid():
                error = serializer.errors
                errors = json.loads(json.dumps(error))

                    # combine errors to form a single word
                errors_data = Utils.extract_validation_error(errors)
                return Response(error_(message=errors_data),status=status.HTTP_200_OK)
            
            data = serializer.validated_data
            
            token_data = data.get("token_data", {})
            message = "OTP verified successfully."
            return Response(success_(response=token_data,message=message),
                            status=status.HTTP_200_OK)
            
        except Exception as e:
            import traceback
            print(traceback.format_exc())
            return Response(error_(message=str(e)),status=status.HTTP_400_BAD_REQUEST)
        

#Create Account (After Password Setup)
class WebCreateAccountAPIView(APIView):
    permission_classes = [AllowAny]

    def get_expiry_seconds(self, token_payload):
        now = datetime.now(dt_timezone.utc)
        exp_dt = datetime.fromtimestamp(token_payload['exp'], tz=dt_timezone.utc)
        return max(0, int((exp_dt - now).total_seconds()))
    
    def post(self, request):
        try:
            password = request.data.get("password", None)

            serializer = WebCreateAccountSerializer(data=request.data)
            
            if not serializer.is_valid():
                error = serializer.errors
                errors = json.loads(json.dumps(error))

                    # combine errors to form a single word
                errors_data = Utils.extract_validation_error(errors)
                return Response(error_(message=errors_data),status=status.HTTP_200_OK)
            
            data = serializer.validated_data

            user = serializer.set_password(data,password)
            refresh = RefreshToken.for_user(user)

            access_payload = jwt.decode(str(refresh.access_token), options={"verify_signature": False})
            refresh_payload = jwt.decode(str(refresh), options={"verify_signature": False})
            response_data= {
                "access": str(refresh.access_token),
                "refresh": str(refresh),
                "user": Utils.get_user_data(user),
                "device_id": Utils.get_device_id(request),
                "access_expires": access_payload['exp'],
                "refresh_expires": refresh_payload['exp'],
                "expires_in": {
                    "access": self.get_expiry_seconds(access_payload),
                    "refresh": self.get_expiry_seconds(refresh_payload)
                },
                **AccountUtils.get_common_login_response(user=user)            }
            message = "Account created successfully!"
            return Response(success_(response=response_data,message=message),
                status=status.HTTP_200_OK
            ) 
        except Exception as e:
            return Response(error_(message = str(e)),
                status=status.HTTP_400_BAD_REQUEST
            )

class ChangePasswordAPIView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self,request):
        try:
            serializer = ChangePasswordSerializer(data=request.data, context={'request': request})
            if serializer.is_valid():
                serializer.save()
                return Response(success_(response={},message=const.PASSWORD_CHANGED),
                status=status.HTTP_200_OK
                )
            error = serializer.errors
            errors = json.loads(json.dumps(error))

            errors_data = Utils.extract_validation_error(errors)
            return Response(error_(message=errors_data),status=status.HTTP_200_OK)
            
        except Exception as e:
            return Response(error_(message = str(e)),
                status=status.HTTP_400_BAD_REQUEST
            )

class AccountSessionList(APIView):
    permission_classes = []

    def get(self, request):
        try:
            session_data = Session.objects.filter(user=request.user)
            message = "Interests list"
            return Response(success_(response={},message=message),
                status=status.HTTP_200_OK
            )
        except Exception as e:
            import traceback
            print(traceback.format_exc())
            return Response(error_(message=str(e)),status=status.HTTP_400_BAD_REQUEST)
        
class AccountDeletionAPIView(APIView):
    serializer_class = AccountDeletionReasonSerializer
    permission_classes = [IsAuthenticated]

    def get_serializer(self, *args, **kwargs):
        return self.serializer_class(*args, **kwargs)

    def perform_destroy(self, user):
        user.is_active = False
        user.save(update_fields=['is_active'])

    def post(self, request, *args, **kwargs):
        try:
            user = request.user

            if AccountDeletionReason.objects.filter(user=user).exists():
                return Response(
                    error_(message=const.ACCOUNT_DELETED_ALREADY),
                    status=status.HTTP_200_OK
                )

            serializer = self.get_serializer(data=request.data)
            if serializer.is_valid():
                serializer.save(user=user)
                self.perform_destroy(user)
                return Response(
                    success_(response={}, message=const.ACCOUNT_DELETED),
                    status=status.HTTP_200_OK
                )
            error = serializer.errors
            errors = json.loads(json.dumps(error))

            errors_data = Utils.extract_validation_error(errors)
            return Response(error_(message=errors_data),status=status.HTTP_200_OK)

        except Exception as e:
            return Response(
                error_(message=const.SOMETHING_WENT_WRONG),
                status=status.HTTP_400_BAD_REQUEST
            )

